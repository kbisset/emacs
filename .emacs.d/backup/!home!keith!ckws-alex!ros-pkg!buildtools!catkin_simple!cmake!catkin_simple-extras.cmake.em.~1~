# Generated from: catkin_simple/cmake/catkin_simple-extras.cmake.em

set(CMAKE_C_FLAGS                 "-Wall -Werror -fopenmp -std=gnu99")
<<<<<<< HEAD
# Add -Wno-unused-local-typedefs to turn off boost warnings
set(CMAKE_CXX_FLAGS               "-Wall -Wno-unused-local-typedefs -Wno-deprecated-declarations -Wno-sign-compare -fopenmp -std=c++11 -Wno-reorder")
=======
set(CMAKE_CXX_FLAGS               "-Wall -Werror -Wno-unused-local-typedefs -fopenmp -std=c++11 -Wno-reorder")
>>>>>>> Use seperatly compiled, non-system versions of boost, cpp-netlib, and pcl. See README-branch.txt

if(${CMAKE_SYSTEM_PROCESSOR} MATCHES ".*arm.*")
  MESSAGE("using arm")
  set(CMAKE_C_FLAGS                 "${CMAKE_C_FLAGS} -mthumb -mfpu=neon-fp16")
  set(CMAKE_CXX_FLAGS               "${CMAKE_CXX_FLAGS} -mthumb -mfpu=neon-fp16")
endif() 

<<<<<<< HEAD
# Set var for ckws/devel, since CATKIN_DEVEL_PREFIX points to package devel dir which is
# then linked to in ckws/devel
set(LIGHTHOUSE_DEVEL_PREFIX ${PROJECT_BINARY_DIR}/../../devel)

# Use downloaded boost.
set(BOOST_ROOT ${LIGHTHOUSE_DEVEL_PREFIX})
set(Boost_NO_SYSTEM_PATHS ON)
set(Boost_USE_STATIC_LIBS OFF)
set(Boost_USE_MULTITHREADED ON)  
set(Boost_USE_STATIC_RUNTIME OFF) 

set(PCL_ROOT ${LIGHTHOUSE_DEVEL_PREFIX})
set(PCL_DIR ${LIGHTHOUSE_DEVEL_PREFIX}/share/pcl-1.7/PCLConfig.cmake)
=======
# Use downloaded boost.
set(BOOST_ROOT /home/keith/ckws/devel)
set(PCL_ROOT /home/keith/ckws/devel)
set(PCL_DIR /home/keith/ckws/devel/share/pcl-1.7/PCLConfig.cmake)
>>>>>>> Use seperatly compiled, non-system versions of boost, cpp-netlib, and pcl. See README-branch.txt

# In debug mode we have assertions and debugging symbols, but not
# optimizations that might complicate debugging.  This is a fairly
# extreme case, to be used when it is too hard to debug in RelWithDebInfo.
set(CMAKE_C_FLAGS_DEBUG                 "-O0 -g")
set(CMAKE_CXX_FLAGS_DEBUG ${CMAKE_C_FLAGS_DEBUG})

# RelWithDebInfo gives you optimizations, debug symbols, and assertions.
# This is meant for the common case of writing new code which you want
# to be optimized but are still debugging.  We spend most of our time here.
set(CMAKE_C_FLAGS_RELWITHDEBINFO                 "-O3 -g")
set(CMAKE_CXX_FLAGS_RELWITHDEBINFO ${CMAKE_C_FLAGS_RELWITHDEBINFO})

# In release mode we pull out the debugging symbols.  Still no assertions,
# though.  For almost everything we are doing we want assertions to catch
# bugs that adversely affect classifier accuracy without otherwise revealing
# themselves.  At some point in the future it might be reasonable to
# add -DNDEBUG to this, which disables assertions.
set(CMAKE_C_FLAGS_RELEASE                 "-O3")
set(CMAKE_CXX_FLAGS_RELEASE ${CMAKE_C_FLAGS_RELEASE})

# Unless otherwise specified, use RelWithDebInfo.
if(x${CMAKE_BUILD_TYPE} STREQUAL "x")
  set(CMAKE_BUILD_TYPE RelWithDebInfo)
endif()


if(_CATKIN_SIMPLE_EXTRAS_INCLUDED_)
  return()
endif()
set(_CATKIN_SIMPLE_EXTRAS_INCLUDED_ TRUE)

include(CMakeParseArguments)

@[if DEVELSPACE]@
# cmake dir in develspace
set(catkin_simple_CMAKE_DIR "@(CMAKE_CURRENT_SOURCE_DIR)/cmake")
@[else]@
# cmake dir in installspace
set(catkin_simple_CMAKE_DIR "@(PKG_CMAKE_DIR)")
@[end if]@

macro(catkin_simple)
  if(TARGET ${PROJECT_NAME}_package)
    message(WARNING "Could not create target '${${PROJECT_NAME}_package}' for project ${PROJECT_NAME}, as it already exists.")
  endif()
  add_custom_target(${PROJECT_NAME}_package)
  set(${PROJECT_NAME}_TARGETS)
  set(${PROJECT_NAME}_LIBRARIES)

  find_package(catkin REQUIRED)
  # call catkin_package_xml() if it has not been called before
  if(NOT _CATKIN_CURRENT_PACKAGE)
    catkin_package_xml()
  endif()

  set(${PROJECT_NAME}_CATKIN_BUILD_DEPENDS)
  set(${PROJECT_NAME}_CATKIN_BUILD_DEPENDS_EXPORTED_TARGETS)
  foreach(dep ${${PROJECT_NAME}_BUILD_DEPENDS})
    find_package(${dep} QUIET)
    if(${dep}_FOUND_CATKIN_PROJECT)
      list(APPEND ${PROJECT_NAME}_CATKIN_BUILD_DEPENDS ${dep})
      list(APPEND ${PROJECT_NAME}_CATKIN_BUILD_DEPENDS_EXPORTED_TARGETS ${${dep}_EXPORTED_TARGETS})
    endif()
  endforeach()

  # Let find_package(catkin ...) do the heavy lifting
  find_package(catkin REQUIRED COMPONENTS ${${PROJECT_NAME}_CATKIN_BUILD_DEPENDS})

  # add include directory if available
  set(${PROJECT_NAME}_LOCAL_INCLUDE_DIR ${CMAKE_CURRENT_SOURCE_DIR}/include)
  if(NOT IS_DIRECTORY ${${PROJECT_NAME}_LOCAL_INCLUDE_DIR})
    set(${PROJECT_NAME}_LOCAL_INCLUDE_DIR)
  endif()
  include_directories(${${PROJECT_NAME}_LOCAL_INCLUDE_DIR} ${catkin_INCLUDE_DIRS} /opt/ros/kinetic/include)

  # perform action/msg/srv generation if necessary
  if(message_generation_FOUND_CATKIN_PROJECT)
    set(${PROJECT_NAME}_DO_MESSAGE_GENERATION FALSE)
    # add action files if available
    set(${PROJECT_NAME}_LOCAL_ACTION_DIR ${CMAKE_CURRENT_SOURCE_DIR}/action)
    if(NOT IS_DIRECTORY ${${PROJECT_NAME}_LOCAL_ACTION_DIR})
      set(${PROJECT_NAME}_LOCAL_ACTION_DIR)
    endif()
    if(${PROJECT_NAME}_LOCAL_ACTION_DIR)
      add_action_files(DIRECTORY action)
      set(${PROJECT_NAME}_DO_MESSAGE_GENERATION TRUE)
    endif()

    # add message files if available
    set(${PROJECT_NAME}_LOCAL_MSG_DIR ${CMAKE_CURRENT_SOURCE_DIR}/msg)
    if(NOT IS_DIRECTORY ${${PROJECT_NAME}_LOCAL_MSG_DIR})
      set(${PROJECT_NAME}_LOCAL_MSG_DIR)
    endif()
    if(${PROJECT_NAME}_LOCAL_MSG_DIR)
      add_message_files(DIRECTORY msg)
      set(${PROJECT_NAME}_DO_MESSAGE_GENERATION TRUE)
    endif()

    # add service files if available
    set(${PROJECT_NAME}_LOCAL_SRV_DIR ${CMAKE_CURRENT_SOURCE_DIR}/srv)
    if(NOT IS_DIRECTORY ${${PROJECT_NAME}_LOCAL_SRV_DIR})
      set(${PROJECT_NAME}_LOCAL_SRV_DIR)
    endif()
    if(${PROJECT_NAME}_LOCAL_SRV_DIR)
      add_service_files(DIRECTORY srv)
      set(${PROJECT_NAME}_DO_MESSAGE_GENERATION TRUE)
    endif()

    # generate messages if necessary
    if(${PROJECT_NAME}_DO_MESSAGE_GENERATION)
      # identify all build dependencies which contain messages
      set(${PROJECT_NAME}_MSG_PACKAGES)
      foreach(dep ${${PROJECT_NAME}_CATKIN_BUILD_DEPENDS})
        set(${PROJECT_NAME}_MSG_PACKAGE_FILE ${${dep}_DIR}/${dep}-msg-paths.cmake)
        if(EXISTS ${${PROJECT_NAME}_MSG_PACKAGE_FILE})
          list(APPEND ${PROJECT_NAME}_MSG_PACKAGES ${dep})
        endif()
      endforeach()
      generate_messages(DEPENDENCIES ${${PROJECT_NAME}_MSG_PACKAGES})
      # add additional exported targets coming from generate_messages()
      list(INSERT ${PROJECT_NAME}_CATKIN_BUILD_DEPENDS_EXPORTED_TARGETS 0 ${${PROJECT_NAME}_EXPORTED_TARGETS})
    endif()
  endif()
endmacro()

macro(cs_add_targets_to_package)
  add_dependencies(${PROJECT_NAME}_package ${ARGN})
  list(APPEND ${PROJECT_NAME}_TARGETS ${ARGN})
endmacro()

macro(cs_add_executable _target)
  if(${_target} STREQUAL ${PROJECT_NAME}_package)
    message(WARNING "Could not create executable with name '${_target}' as '${PROJECT_NAME}_package' is reserved for the top level target name for this project.")
  endif()
  cmake_parse_arguments(cs_add_executable_args "NO_AUTO_LINK;NO_AUTO_DEP" "" "" ${ARGN})
  add_executable(${_target} ${cs_add_executable_args_UNPARSED_ARGUMENTS})
  if(NOT cs_add_executable_args_NO_AUTO_LINK)
    target_link_libraries(${_target} ${catkin_LIBRARIES})
  endif()
  if(NOT cs_add_executable_args_NO_AUTO_DEP)
    if(NOT "${${PROJECT_NAME}_CATKIN_BUILD_DEPENDS_EXPORTED_TARGETS}" STREQUAL "")
      add_dependencies(${_target} ${${PROJECT_NAME}_CATKIN_BUILD_DEPENDS_EXPORTED_TARGETS})
    endif()
  endif()
  cs_add_targets_to_package(${_target})
endmacro()

macro(cs_add_library _target)
  if(${_target} STREQUAL ${PROJECT_NAME}_package)
    message(WARNING "Could not create library with name '${_target}' as '${PROJECT_NAME}_package' is reserved for the top level target name for this project.")
  endif()
  cmake_parse_arguments(cs_add_library "NO_AUTO_LINK;NO_AUTO_DEP;NO_AUTO_EXPORT" "" "" ${ARGN})
  add_library(${_target} ${cs_add_library_UNPARSED_ARGUMENTS})
  if(NOT cs_add_library_NO_AUTO_LINK)
    target_link_libraries(${_target} ${catkin_LIBRARIES})
  endif()
  if(NOT cs_add_library_NO_AUTO_DEP)
    if(NOT "${${PROJECT_NAME}_CATKIN_BUILD_DEPENDS_EXPORTED_TARGETS}" STREQUAL "")
      add_dependencies(${_target} ${${PROJECT_NAME}_CATKIN_BUILD_DEPENDS_EXPORTED_TARGETS})
    endif()
  endif()
  if(NOT cs_add_library_NO_AUTO_EXPORT)
    list(APPEND ${PROJECT_NAME}_LIBRARIES ${_target})
  endif()
  cs_add_targets_to_package(${_target})
#  set_target_properties(${_target} PROPERTIES COMPILE_FLAGS ${JARVIS_EXTRA_CFLAGS})
endmacro()

macro(cs_install)
  # Install targets (exec's and lib's)
  install(TARGETS ${${PROJECT_NAME}_TARGETS} ${ARGN}
    ARCHIVE DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION}
    LIBRARY DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION}
    RUNTIME DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION}
  )
  if(${${PROJECT_NAME}_LOCAL_INCLUDE_DIR})
    # Install include directory
    install(DIRECTORY ${${PROJECT_NAME}_LOCAL_INCLUDE_DIR}/
      DESTINATION ${CATKIN_PACKAGE_INCLUDE_DESTINATION}
      FILES_MATCHING PATTERN "*.h" PATTERN "*.hpp"
      PATTERN ".svn" EXCLUDE
    )
  endif()
endmacro()

macro(cs_install_scripts)
  install(PROGRAMS ${ARGN} DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION})
endmacro()

macro(cs_export)
  cmake_parse_arguments(CS_PROJECT
    "" "" "INCLUDE_DIRS;LIBRARIES;CATKIN_DEPENDS;DEPENDS;CFG_EXTRAS"
    ${ARGN})

  set(${PROJECT_NAME}_CATKIN_RUN_DEPENDS)
  foreach(dep ${${PROJECT_NAME}_RUN_DEPENDS})
    find_package(${dep} QUIET)
    if(${dep}_FOUND_CATKIN_PROJECT)
      list(APPEND ${PROJECT_NAME}_CATKIN_RUN_DEPENDS ${dep})
    endif()
  endforeach()

  catkin_package(
    INCLUDE_DIRS ${${PROJECT_NAME}_LOCAL_INCLUDE_DIR} ${CS_PROJECT_INCLUDE_DIRS}
    LIBRARIES ${${PROJECT_NAME}_LIBRARIES} ${CS_PROJECT_LIBRARIES}
    CATKIN_DEPENDS ${${PROJECT_NAME}_CATKIN_RUN_DEPENDS} ${CS_PROJECT_CATKIN_DEPENDS}
    DEPENDS ${CS_PROJECT_DEPENDS}
    CFG_EXTRAS ${CS_PROJECT_CFG_EXTRAS}
  )
endmacro()
